### 分析

第一眼看，奥，这不 AC 自动机吗，我会！

一个棋谱就相当于一个字符串嘛，嗯嗯，不难的！

只需要存一个对应定式的 $\operatorname{name}$ 数组就好了。

快乐对着板子魔改一通，一交，全 WA 了。

第二眼看，奥，要开大字符集，我会！

然后再一交，MLE。收获了 30 pts 的好成绩。

（血压上来了）

第三眼看，奥，字符集太大了。这怎么办呢。

因为其实真正会出现的字符其实很少，~~掰指头~~一数只有 $33$ 个，那么我们就可以建立对字符的映射 $tt$ ，压缩字符集的大小从而避免 MLE 的悲惨命运。

~~（可以打一个表的嘛）~~

剩下的就是 AC 自动机的板子了。

### 代码

```cpp
#include <cstring>
#include <iostream>
#include <queue>

const int MAX_N = 700050;
const int MAX_M = 2050;

int tree[MAX_N][35], exi[MAX_N], nxt[MAX_N], ans[MAX_M];
int tot;
std::string s[MAX_M];

int tt[255] = {0,  0,  0,  0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,
               0,  0,  0,  0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,
               0,  0,  0,  0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  16, 17, 18, 19, 20,
               21, 22, 23, 0, 0, 0, 0, 0, 0, 0,  0,  0,  3,  0,  0,  0,  0,  0,
               0,  0,  0,  1, 0, 0, 4, 0, 6, 2,  5,  0,  0,  0,  0,  0,  0,  0,
               0,  0,  0,  0, 0, 0, 0, 8, 9, 10, 11, 12, 13, 14, 15};

void build();

void insert(std::string s, int c);

void query(std::string s);

int main() {
    std::ios::sync_with_stdio(false);

    int n, m;
    std::cin >> n >> m;

    auto* nam = new std::string[n + 5];
    for (int i = 1; i <= n; i++) {
        int k;
        std::cin >> k;
        std::getline(std::cin, nam[i]);
        std::getline(std::cin, nam[i]);

        for (int j = 1; j <= k; j++) {
            std::string x;
            std::cin >> x;
            s[i] += x;
        }
        insert(s[i], i);
    }
    build();

    std::string k;
    for (int i = 1; i <= m; i++) {
        std::string s;
        std::cin >> s;
        k += s;
    }
    query(k);

    for (int i = 1; i <= n; i++) {
        if (ans[i]) {
            std::cout << nam[i] << '\n';
        }
    }

    return 0;
}

void build() {
    std::queue<int> q;
    for (int i = 0; i < 26; i++) {
        if (tree[0][i]) {
            q.push(tree[0][i]);
        }
    }
    while (!q.empty()) {
        int x = q.front();
        q.pop();
        for (int i = 0; i < 26; i++) {
            if (!tree[x][i]) {
                tree[x][i] = tree[nxt[x]][i];
            } else {
                q.push(tree[x][i]);
                nxt[tree[x][i]] = tree[nxt[x]][i];
            }
        }
    }
}

void insert(std::string s, int c) {
    int x = 0;
    for (int i = 0; s[i]; i++) {
        int ch = tt[s[i]];
        if (!tree[x][ch]) {
            tree[x][ch] = ++tot;
        }
        x = tree[x][ch];
    }
    exi[x] = c;
}

void query(std::string s) {
    int x = 0;
    for (int i = 0; s[i]; i++) {
        int ch = tt[s[i]];
        x = tree[x][ch];
        for (int j = x; j; j = nxt[j]) {
            ans[exi[j]]++;
        }
    }
}
```

